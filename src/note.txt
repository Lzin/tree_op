1.树结构的基础部分

为什么需要树这种结构
    1.数组存储方式的分析
        优点: 通过下标的方式去访问，速度快，对于有序数组，还可以使用二分查找提交检索的速度
        缺点: 如果要检索具体的某个值，或者插入值，整个数组会整体移动，效率较低。同时如果需要扩容的话，需要创建新的数组
            //ArrayList底层维护了一个Object数组，底层仍然 进行底层的扩容


    2. 链式存储方式的分析
        优点: 在一定程度上对数组存储的方式有优化(比如在插入值的时候,改变尾指针即可)
        缺点: 在进行检索的时候，效率依然比较低,比如在检索具体的值，需要从头节点进行遍历

    3. 树存储方式的分析
        可以提高数据存储和读取的效率，比如利用二叉排序树，既可以保证数据的检索速度，同时保证数据的插入，删除和修改的速度
            //红黑树
        查找,删除，修改都很快


2.二叉树 (核心在于递归)
    1.每一个节点最多只能有两个节点的一种形式称为二叉树
    2.二叉树的子节点分为左节点和右节点
    3.如果该二叉树的所有叶子节点都在最后一层，并且节点总数为2^n-1（n为层数），称为满二叉树
    4.若设二叉树的深度为k,除第k层外,其他各层(1～(k-1)层)的节点数都达到最大值,且第k层所有的节点都连续集中在最左边,这样的树就是完全二叉树

3.二叉树的遍历
    1.说明一下
        1.前序遍历: 父->左->右
        2.中序遍历: 左->父->右
        3.后序遍历: 左->右->父
        看输出父节点的顺序，就可以判断是哪种方式

    2.遍历思路
        2-1创建一棵二叉树
        2-2前序遍历(输出当前节点->左->右)
            输出当前节点(根节点)
            如果左子节点不为空，则递归继续向前序遍历
            如果右子节点不为空，则递归继续向前序遍历

        2-3:中序遍历(左->输出当前节点->右)
            如果当前节点(根节点)的左子节点不为空，则递归中序遍历
            输出当前节点
            如果当前节点的右子节点不为空，则递归继续中序遍历

        2-4:后序遍历(左->右->输出当前节点)
            如果当前节点(根节点)的左子节点不为空，则递归后序遍历，输出当前节点
            如果当前节点的右子节点不为空，则递归继续后序遍历
            输出当前节点

        * 按照输出节点的时机，可以看出是哪一种方法

4.二叉树的查找(查找指定的节点)

   查找思路
        2-1:前序查找(和节点比较->左->右)
            和节点比较:  先判断当前节点是否和带比较节点相等，如果相等则直接返回
            左:        如果相等，判断当前节点的左节点是否为空，如果不为空则递归前序查找。如果找到了返回，否则
            右;        如果找到，判断当前节点的右节点是否为空，如果不为空则递归前序查找，如果找到了返回，没找到返回null(所以就可以直接返回该节点即可)

        2-2:中序查找(左->和节点比较->右)
            先判断当前节点的左子节点是否为空，如果不为空则递归中序查找
            如果找到，则返回，如果没有找到和当前节点比较，如果相等返回当前节点，否则继续进行右递归中序查找
            如果右递归中序查找找到，就返回，否则返回null

        2-3:后序查找(左->右->和节点比较)
            先判断当前节点的左节点是否为空，如果不为空则递归后序查找
            如果找到了,则返回，如果没有找到就判断当前节点的右子节点是否为空，如果不为空则右递归进行后序查找，如果找到了则返回
            否则和当前节点进行比较，如果是则返回，否则返回null

        *递归结束条件 node->left=null || node->right=null;

5. 二叉树的删除操作
    (1):规定
        如果删除的是叶子节点,就直接删除该节点
        如果删除的节点是非叶子节点，则删除该子树

    (2):操作思路
        1.如果树是空树root，如果只有一个root节点，就将二叉树置空
        2.二叉树是单向的，所以我们判断当前节点的子节点是否需要删除,而不能去判断当前这个节点是不是需要删除的
        3.如果当前节点的左子节点不为空，并且左子节点的编号就是需要删除的节点。就将this.left=null，并且返回即可(结束删除任务)
        4.如果当前节点的右子节点不为空，并且右子节点的编号就是需要删除的节点，就将this.right=null，并且返回即可(结束删除任务)
        5.如果第2 3没有完成，我们就要向左子树进行递归删除
        6.如果4没有完成，我们就要向右子树进行递归删除

6. 二叉树的顺序存储
    (1):说明
        从数据存储来看，数组存储方式和树的存储方式可以相互转换，即:数组可以转换为树，而树可以转换为数组

    (2):要求
        .要求以数组的方式存放arr: [1,2,3,4,5,6,7]  参考完全二叉树的摆放
        .要求在遍历数组arr时，仍然可以以前序遍历,中序遍历，后序遍历的方式完成节点的遍历
        .(总的来说就是把一棵树以数组的方式进行存放，但是依旧可以按照树的遍历方式呈现)
        .这样我们称这棵树为顺序存储二叉树

    (3):特点
        .顺序二叉树一般只考虑完全二叉树
        .第n个元素的左子节点为2*n+1
        .第n个元素的右子节点为2*n+2
        .第n个元素的父节点为(n-1)/2

        n表示二叉树的第几个元素(按0开始编号)
            需求: 给一个数组{1,2,3,4,5,6,7}，要求以二叉树前序遍历的方式进行遍历。















