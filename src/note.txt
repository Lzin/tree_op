1.树结构的基础部分

为什么需要树这种结构
    1.数组存储方式的分析
        优点: 通过下标的方式去访问，速度快，对于有序数组，还可以使用二分查找提交检索的速度
        缺点: 如果要检索具体的某个值，或者插入值，整个数组会整体移动，效率较低。同时如果需要扩容的话，需要创建新的数组
            //ArrayList底层维护了一个Object数组，底层仍然 进行底层的扩容


    2. 链式存储方式的分析
        优点: 在一定程度上对数组存储的方式有优化(比如在插入值的时候,改变尾指针即可)
        缺点: 在进行检索的时候，效率依然比较低,比如在检索具体的值，需要从头节点进行遍历

    3. 树存储方式的分析
        可以提高数据存储和读取的效率，比如利用二叉排序树，既可以保证数据的检索速度，同时保证数据的插入，删除和修改的速度
            //红黑树
        查找,删除，修改都很快


2.二叉树 (核心在于递归)
    1.每一个节点最多只能有两个节点的一种形式称为二叉树
    2.二叉树的子节点分为左节点和右节点
    3.如果该二叉树的所有叶子节点都在最后一层，并且节点总数为2^n-1（n为层数），称为满二叉树
    4.若设二叉树的深度为k,除第k层外,其他各层(1～(k-1)层)的节点数都达到最大值,且第k层所有的节点都连续集中在最左边,这样的树就是完全二叉树

3.二叉树的遍历
    1.说明一下
        1.前序遍历: 父->左->右
        2.中序遍历: 左->父->右
        3.后序遍历: 左->右->父
        看输出父节点的顺序，就可以判断是哪种方式

    2.遍历思路
        2-1创建一棵二叉树
        2-2前序遍历(输出当前节点->左->右)
            输出当前节点(根节点)
            如果左子节点不为空，则递归继续向前序遍历
            如果右子节点不为空，则递归继续向前序遍历

        2-3:中序遍历(左->输出当前节点->右)
            如果当前节点(根节点)的左子节点不为空，则递归中序遍历
            输出当前节点
            如果当前节点的右子节点不为空，则递归继续中序遍历

        2-4:后序遍历(左->右->输出当前节点)
            如果当前节点(根节点)的左子节点不为空，则递归后序遍历，输出当前节点
            如果当前节点的右子节点不为空，则递归继续后序遍历
            输出当前节点

        * 按照输出节点的时机，可以看出是哪一种方法

4.二叉树的查找(查找指定的节点)

   查找思路
        2-1:前序查找(和节点比较->左->右)
            和节点比较:  先判断当前节点是否和带比较节点相等，如果相等则直接返回
            左:        如果相等，判断当前节点的左节点是否为空，如果不为空则递归前序查找。如果找到了返回，否则
            右;        如果找到，判断当前节点的右节点是否为空，如果不为空则递归前序查找，如果找到了返回，没找到返回null(所以就可以直接返回该节点即可)

        2-2:中序查找(左->和节点比较->右)
            先判断当前节点的左子节点是否为空，如果不为空则递归中序查找
            如果找到，则返回，如果没有找到和当前节点比较，如果相等返回当前节点，否则继续进行右递归中序查找
            如果右递归中序查找找到，就返回，否则返回null

        2-3:后序查找(左->右->和节点比较)
            先判断当前节点的左节点是否为空，如果不为空则递归后序查找
            如果找到了,则返回，如果没有找到就判断当前节点的右子节点是否为空，如果不为空则右递归进行后序查找，如果找到了则返回
            否则和当前节点进行比较，如果是则返回，否则返回null

        *递归结束条件 node->left=null || node->right=null;









